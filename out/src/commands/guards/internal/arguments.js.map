{"version":3,"file":"arguments.js","sourceRoot":"./src/","sources":["src/commands/guards/internal/arguments.ts"],"names":[],"mappings":"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","sourcesContent":["import { Channel, Guild, GuildMember, Message, RichEmbed, Role, User } from \"discord.js\";\nimport Constants from \"../../../Constants\";\nimport { Command, CommandHandler } from \"../../util\";\nimport { Miscellaneous } from \"../../../util\";\n\n/**\n * This is not a public guard. This is part of the arguments api.\n * \n * You may include this guard in a command by using the usage entry on command opts\n * \n * opts: {\n *  usage: {\n *    description: \"Dies\",\n *    args: []\n *  }\n * }\n */\n\nexport namespace ArgumentSDK {\n    /**\n     * An argument slot.\n     */\n    export interface Argument {\n        name: string;\n        /**\n         * If the type is a function, it takes the place of a validator function and returns the error or null.\n         */\n        type: \"string\" | \"boolean\" | \"number\" | \"user\" | \"member\" | \"guild\" | \"channel\" | \"message\" | \"role\" | Validator;\n        unlimited?: boolean;\n        required?: boolean;\n        description?: string;\n    }\n\n    export type ArgumentType = boolean | number | string | User | GuildMember | Guild | Channel | Message | Role;\n\n    /**\n     * A function that inspects the arguments and returns errors, or null.\n     * \n     * The function takes the entire argument array but should inspect only one\n     * argument, as each validator function is for a specific argument slot.\n     */\n    export type Validator = (args: string[], message: Message) => Promise<string | null>;\n\n    /**\n     * Checks the type of a given value\n     * @param value the value to check\n     * @param type the typeof to validate\n     * @param error the error to return\n     */\n    export function parse<T>(value: string, type: string, error: T): { error: T | null, value: any } {\n        try {\n            value = JSON.parse(value);\n            if (typeof value !== type) {\n                return { error, value };\n            }\n            return { error: null, value };\n        } catch (e) {\n            return { error, value };\n        }\n    }\n\n    /**\n     * Functions related to extracting IDs from strings\n     */\n    export namespace Matching {\n        const channelRegex = /(?:<?#?)(\\d{17,19})(?:>?)/g;\n        const userRegex = /(?:<?@?!?)(\\d{17,19}|1)(?:>?)/g;\n        const roleRegex = /(?:<?@?&?)(\\d{17,19}|1)(?:>?)/g\n\n        /**\n         * Extracts the channel ID\n         * @param str the string to match\n         */\n        export const channel = (str: string) => {\n            channelRegex.lastIndex = 0;\n            const match = channelRegex.exec(str);\n            return match && match[1];\n        }\n\n        /**\n         * Extracts the UID\n         * @param str the string to match\n         */\n        export const user = (str: string) => {\n            userRegex.lastIndex = 0;\n            const match = userRegex.exec(str);\n            return match && match[1];\n        }\n\n        export const role = (role: string) => {\n            roleRegex.lastIndex = 0;\n            const match = roleRegex.exec(role);\n            return match && match[1];\n        }\n    }\n}\n\nconst FuzzyLookup = <T extends { id: string }>(comparisons: Array<{\n    property: string | ((obj: T) => string);\n    equalsScore: number;\n    includesScore: number;\n}>, entities: T[], param: string) => {\n    let name = param.toLowerCase();\n    const scores: {[key: string]: number} = {};\n\n    entities.forEach((entity) => {\n        let score = 0;\n        \n        comparisons.forEach(({property, equalsScore, includesScore}) => {\n            const compareValue = (typeof property === \"function\" ? property(entity) : (entity[property] as any as string) || \"\").toLowerCase();\n\n            if (name === compareValue) score += equalsScore;\n            if (compareValue.includes(name)) score += 3;\n        });\n\n        if (score === 0) return;\n\n\n        scores[entity.id] = score;\n    });\n\n    const sorted = Miscellaneous.sortNumbersInObject(scores);\n\n    return sorted[0][0];\n}\n\n/**\n * Creates an argument parsing guard\n * @param desc The command description\n * @param args The command arguments\n * @param command The command itself\n */\nexport const Argumented: (command: Command) => CommandHandler = (command) => {\n    // every idx of validators array corresponds to args array\n    const validators: Array<{ name: string, validator: ArgumentSDK.Validator } | null> = [];\n\n    let syntax: string = command.opts.name;\n\n    const args = command.opts.usage!.args || [];\n\n    for (let argIndex = 0; argIndex < args.length; argIndex++) {\n        const arg = args[argIndex];\n        if (!arg) {\n            // there's no argument data for this, including a name. we use param{idx} as the name\n            syntax += ` <param${argIndex}>`;\n            validators[argIndex] = null;\n            continue;\n        }\n        const { name, type, unlimited, required } = arg;\n        // appends this argument slot to the syntax str\n        syntax += ` ${required === false ? \"[\" : \"<\"}${unlimited ? '...' : ''}${name}${required === false ? \"]\" : \">\"}`;\n        validators[argIndex] = {\n            name,\n            validator: async (args, msg) => {\n                let checkParams: string[] = unlimited ? args.slice(argIndex) : [args[argIndex]];\n                checkParams = checkParams.filter(param => typeof param !== \"undefined\");\n\n                if (checkParams.length === 0) {\n                    if (required !== false) {\n                        return \"This argument is required.\";\n                    }\n                    return null;\n                }\n\n                switch (type) {\n                    case \"string\":\n                        // there's really nothing to validate if it's a string, it's already a string.\n                        break;\n                    // boolean and number are identical in how they're parsed, so they're the same handling code\n                    case \"boolean\":\n                    case \"number\":\n                        for (let i = 0; i < checkParams.length; i++) {\n                            const param = checkParams[i];\n                            const result = ArgumentSDK.parse(param, type, `Must be a ${type}.`);\n                            checkParams[i] = result.value;\n                            if (result.error) {\n                                return result.error;\n                            }\n                        }\n                        break;\n                    case \"user\":\n                    case \"member\":\n                        for (let i = 0; i < checkParams.length; i++) {\n                            const param = checkParams[i];\n                            let userID = ArgumentSDK.Matching.user(param);\n                            if (!userID) userID = FuzzyLookup([{property: member => member.user.username, equalsScore: 10, includesScore: 3}, {property: \"nickname\", equalsScore: 2, includesScore: 1}], msg.guild.members.array(), param);\n                            checkParams[i] = userID && (type === \"member\" ? msg.guild.members : msg.client.users).get(userID) as any;\n                            if (!checkParams[i]) {\n                                return `Must be a ${type}`;\n                            }\n                        }\n                        break;\n                    case \"guild\":\n                    case \"channel\":\n                    case \"role\":\n                        for (let i = 0; i < checkParams.length; i++) {\n                            const param = checkParams[i];\n                            \n                            if (type === \"guild\") checkParams[i] = msg.client.guilds.get(param as any) as any;\n                            else {\n                                let id = type === \"role\" ? ArgumentSDK.Matching.role(param) : ArgumentSDK.Matching.channel(param);\n\n                                checkParams[i] = type === \"role\" ? msg.guild.roles.get(id!) : msg.client.channels.get(id!) as any;\n                            }\n\n                            const collection = type === \"guild\" ? msg.client.guilds : type === \"role\" ? msg.guild.roles : msg.guild.channels;\n\n                            if (!checkParams[i]) checkParams[i] = collection.get(FuzzyLookup([{property: \"name\" as any, equalsScore: 10, includesScore: 3}], collection.array() as any, param)) as any;\n\n                            if (!checkParams[i]) {\n                                return `Must be a ${type}`;\n                            }\n                        }\n                        break;\n                    case \"message\":\n                        for (let i = 0; i < checkParams.length; i++) {\n                            const param = checkParams[i];\n                            // safely catch and fail\n                            if (!(checkParams[i] = await msg.channel.fetchMessage(param).catch(e => null) as any)) {\n                                return `Must be a ${type}`;\n                            }\n                        }\n                        break;\n                    default:\n                        return await type(args, msg);\n                }\n\n                args.insert(argIndex, checkParams);\n\n                return null;\n            }\n        };\n    }\n\n    (command.opts.usage! as any).syntax = syntax;\n\n    return async (message, next) => {\n        const issues: Array<string | null> = [];\n        let error: boolean = false;\n        for (let i = 0; i < validators.length; i++) {\n            const validator = validators[i];\n            if (!validator) {\n                issues[i] = null;\n                continue;\n            }\n            error = error ? true : !!(issues[i] = await validator.validator(message.args as string[], message));\n        }\n        // there's no errors, so we call next and continue the command flow\n        if (!error) return next();\n        const embed = new RichEmbed();\n        embed.setTitle(`Syntax errors for ${command.opts.name}`);\n        embed.addField(\"Syntax\", `\\`${syntax}\\``);\n        for (let i = 0; i < issues.length; i++) {\n            const validator = validators[i];\n            // again, we use a placeholder name if there's no validator. this is unlikely to happen though. just satisfies tsc.\n            const name = validator ? validator.name : `param${i}`;\n            const issue = issues[i];\n            // we include the type so we can hint to the user what exactly must be provided,\n            // just in case the error message is vague.\n            let type = args[i] && ` (type: ${args[i]!.type})`;\n            if (typeof type !== \"string\") type = \"\" as any;\n            embed.addField(name, issue ? `${Constants.WARNING_EMOJI} ${issue}${type}` : `${Constants.SUCCESS_EMOJI}${type}`, true);\n        }\n        await Promise.all([message.reply(embed), message.warning()]);\n    };\n};\n\nexport type ArgumentType = ArgumentSDK.ArgumentType;"]}