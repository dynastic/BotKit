{"version":3,"file":"util.js","sourceRoot":"./src/","sources":["src/commands/permissions/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { PermissionSet } from \"./types\";\n\nexport namespace _PermissionInternals {\n    /**\n     * Determines whether a node satisfies another node\n     * @param node the node to test\n     * @param satisfyingNode the node to use in testing\n     * \n     * checks for wildcards and for literal matches\n     */\n    export function nodesSatisfy(node: string, satisfyingNode: string): boolean {\n        if (node === satisfyingNode) return true;\n\n        const nodeSegments = node.split('.');;\n        const satisfyingSegments = satisfyingNode.split('.');\n\n        for (let i = 0; i < nodeSegments.length; i++) {\n            if (satisfyingSegments[i] === '*') return true;\n            if (nodeSegments[i] !== satisfyingSegments[i]) break;\n        }\n\n        return false;\n    }\n\n    export function generateNode(length: number = 3) {\n        const generateSegment = () => Math.random().toString(36).replace('0.', '').substring(0, 4);\n    \n        const segments: string[] = [];\n    \n        for (let i = 0; i < length; i++) segments.push(generateSegment());\n    \n        return segments.join(\".\");\n    }\n    \n    export function generateNodes(number: number = 2, length?: number) {\n        const nodes: string[] = [];\n    \n        for (let i = 0; i < number; i++) nodes.push(generateNode(length));\n    \n        return nodes;\n    }\n    \n    export function generateNodePairs(number: number = 2, length?: number, identical: boolean = false) {\n        const nodePairs: string[][] = [];\n    \n        for (let i = 0; i < number; i++) nodePairs.push(identical ? generateNodes(2, length).map((_, i, a) => a[0]) : generateNodes(2, length));\n    \n        return nodePairs;\n    }\n\n    export function generatePermissionSet(): PermissionSet {\n        return {\n            grantedPermissions: _PermissionInternals.generateNodes(),\n            negatedPermissions: _PermissionInternals.generateNodes()\n        };\n    }\n}\n\nexport namespace PermissionsAPI {\n    /**\n     * Determines whether two nodes satisfy eachother\n     * @param node1 the first node to compare\n     * @param node2 the second node to compare\n     * \n     * \"Node\" is a fancy term for a permission string. Each node represents a command or a group of commands to be locked behind the same permission\n     * \n     * Nodes may be satisfied by wildcards at any level of the node except the end.\n     * ex:\n     * \n     * Node: a.b.c.d.e\n     * Tests:\n     * - *: satisfy\n     * - a.*: satisfy\n     * - a.b.*: satisfy\n     * - a.b.c.d.e.*: not satisfy\n     * \n     * Nodes may be satisfied by an identical node\n     * Node: a.b.c.d.e\n     * Tests:\n     * - a.b.c.d.e: satisfy\n     * - anything.else: not satisfy\n     * \n     * @returns whether the nodes are satisfied :)\n     */\n    export function nodesSatisfy(node1: string, node2: string): boolean {\n        return _PermissionInternals.nodesSatisfy(node1, node2) || _PermissionInternals.nodesSatisfy(node2, node1);\n    }\n\n    export namespace Utils {\n        /**\n         * Converts a node string to an array of its components\n         * @param node the node stirng to collapse\n         * \n         * @returns 'a.b.c.d.e' => ['a', 'a.b', 'a.b.c', 'a.b.c.d', 'a.b.c.d.e']\n         */\n        export const segmentNode = (node: string) => node.split('.').reduce((a, c) => {\n            const base = typeof a[a.length - 1] === 'undefined' ? '' : `${a[a.length - 1]}.`;\n            a.push(base + c);\n            return a;\n        }, [] as string[]);\n    }\n\n    export function nodeSatisfiesSet(node: string, set: PermissionSet) {\n        if (!set.grantedPermissions.find(checkNode => nodesSatisfy(node, checkNode))) return false;\n\n        if (set.negatedPermissions.find(checkNode => nodesSatisfy(node, checkNode))) return false;\n\n        return true;\n    }\n\n    export function compositePermissionSet(sets: Array<PermissionSet>): PermissionSet {\n        const grantedPermissions: string[] = [];\n        const negatedPermissions: string[] = [];\n\n        sets.forEach(set => {\n            ArrayUtils.uniqueMerge(grantedPermissions, set.grantedPermissions);\n            ArrayUtils.uniqueMerge(negatedPermissions, set.negatedPermissions)\n        });\n\n        return {\n            grantedPermissions,\n            negatedPermissions\n        };\n    }\n}\n\nexport namespace ArrayUtils {\n    export function uniqueMerge<K, T>(array1: K[], array2: T[]): Array<K | T> {\n        array2.forEach(val => array1.indexOf(<any>val as K) > -1 ? undefined : array1.push(<any>val as K));\n        return array1;\n    }\n}"]}