{"version":3,"file":"util.js","sourceRoot":"./src/","sources":["src/commands/permissions/util.ts"],"names":[],"mappings":";;AAAA,IAAiB,oBAAoB,CAqBpC;AArBD,WAAiB,oBAAoB;IACjC;;;;;;OAMG;IACH,SAAgB,YAAY,CAAC,IAAY,EAAE,cAAsB;QAC7D,IAAI,IAAI,KAAK,cAAc;YAAE,OAAO,IAAI,CAAC;QAEzC,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAAA,CAAC;QACtC,MAAM,kBAAkB,GAAG,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAErD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC1C,IAAI,kBAAkB,CAAC,CAAC,CAAC,KAAK,GAAG;gBAAE,OAAO,IAAI,CAAC;YAC/C,IAAI,YAAY,CAAC,CAAC,CAAC,KAAK,kBAAkB,CAAC,CAAC,CAAC;gBAAE,MAAM;SACxD;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAZe,iCAAY,eAY3B,CAAA;AACL,CAAC,EArBgB,oBAAoB,GAApB,4BAAoB,KAApB,4BAAoB,QAqBpC;AAED;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,SAAgB,YAAY,CAAC,KAAa,EAAE,KAAa;IACrD,OAAO,oBAAoB,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,oBAAoB,CAAC,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AAC9G,CAAC;AAFD,oCAEC;AAED;;;;;GAKG;AACU,QAAA,WAAW,GAAG,CAAC,IAAY,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;IACzE,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC;IACjF,CAAC,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;IACjB,OAAO,CAAC,CAAC;AACb,CAAC,EAAE,EAAc,CAAC,CAAC","sourcesContent":["export namespace _PermissionInternals {\n    /**\n     * Determines whether a node satisfies another node\n     * @param node the node to test\n     * @param satisfyingNode the node to use in testing\n     * \n     * checks for wildcards and for literal matches\n     */\n    export function nodesSatisfy(node: string, satisfyingNode: string): boolean {\n        if (node === satisfyingNode) return true;\n\n        const nodeSegments = node.split('.');;\n        const satisfyingSegments = satisfyingNode.split('.');\n\n        for (let i = 0; i < nodeSegments.length; i++) {\n            if (satisfyingSegments[i] === '*') return true;\n            if (nodeSegments[i] !== satisfyingSegments[i]) break;\n        }\n\n        return false;\n    }\n}\n\n/**\n * Determines whether two nodes satisfy eachother\n * @param node1 the first node to compare\n * @param node2 the second node to compare\n * \n * \"Node\" is a fancy term for a permission string. Each node represents a command or a group of commands to be locked behind the same permission\n * \n * Nodes may be satisfied by wildcards at any level of the node except the end.\n * ex:\n * \n * Node: a.b.c.d.e\n * Tests:\n * - *: satisfy\n * - a.*: satisfy\n * - a.b.*: satisfy\n * - a.b.c.d.e.*: not satisfy\n * \n * Nodes may be satisfied by an identical node\n * Node: a.b.c.d.e\n * Tests:\n * - a.b.c.d.e: satisfy\n * - anything.else: not satisfy\n * \n * @returns whether the nodes are satisfied :)\n */\nexport function nodesSatisfy(node1: string, node2: string): boolean {\n    return _PermissionInternals.nodesSatisfy(node1, node2) || _PermissionInternals.nodesSatisfy(node2, node1);\n}\n\n/**\n * Converts a node string to an array of its components\n * @param node the node stirng to collapse\n * \n * @returns 'a.b.c.d.e' => ['a', 'a.b', 'a.b.c', 'a.b.c.d', 'a.b.c.d.e']\n */\nexport const segmentNode = (node: string) => node.split('.').reduce((a, c) => {\n    const base = typeof a[a.length - 1] === 'undefined' ? '' : `${a[a.length - 1]}.`;\n    a.push(base + c);\n    return a;\n}, [] as string[]);"]}