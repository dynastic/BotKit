{"version":3,"file":"index.js","sourceRoot":"./src/","sources":["src/commands/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {Message} from \"discord.js\";\n\nimport * as CommandUtil from \"./util\";\nimport { COMMAND_PREFIX, ARGUMENT_REGEX, SUCCESS_EMOJI, FAIL_EMOJI, WARNING_EMOJI } from \"../Constants\";\nimport path from \"path\";\nimport {CommandError} from \"./errors\";\nimport Application, { RoleOptions } from \"..\";\nimport { PermissionGuard } from \"./guards\";\n\nimport * as Guards from \"./guards\";\n\nexport interface CommandSystemOptions {\n    directory?: string;\n    preloadExclude?: string[];\n    automaticCategoryNames?: boolean;\n    app: Application;\n}\n\nconst stripStartEnd = (token: string, str: string) => {\n    if (str.startsWith(token) && str.endsWith(token)) str = str.substring(token.length, str.length - token.length);\n    return str;\n}\n\nexport interface CommandMetadata {\n    [command: string]: {\n        syntax: string | undefined;\n        description: string | undefined;\n    } | undefined;\n}\n\n/**\n * A system which loads and tracks commands\n */\nexport default class CommandSystem {\n    public commands: {[key: string]: CommandUtil.Command | undefined} = {};\n    /**\n     * Command metadata, for help etc.\n     */\n    public metadata: CommandMetadata = {};\n    \n    /**\n     * Guards to run on all commands\n     */\n    private readonly globalGuards: CommandUtil.CommandHandler[] = [];\n\n    public constructor(private options: CommandSystemOptions) {\n        this.globalGuards = [];\n        options.app.client.on(\"message\", message => {\n            if (typeof message.isCommand === \"undefined\") {\n                message.isCommand = message.content.startsWith(COMMAND_PREFIX);\n            }\n\n            if (!message.isCommand) return;\n        \n            if (!message.args) {\n                message.args = message.content.substring(COMMAND_PREFIX.length).trim().match(ARGUMENT_REGEX) as string[] || [];\n                for (let i = 0; i < message.args.length; i++) {\n                    message.args[i] = stripStartEnd('\"', message.args[i] as string);\n                    message.args[i] = stripStartEnd(\"'\", message.args[i] as string);\n                }\n            }\n\n            if (message.args.length === 0) return;\n        \n            if (!message.command) {\n                message.command = options.app.commandSystem.commands[message.args[0] as string]!;\n                message.args.shift();\n            }\n        });\n    }\n\n    /**\n     * Loads commands into the tracking system\n     */\n    public async init(): Promise<void> {\n        let commands = this.options.directory ? await CommandUtil.CommandUtils.loadDirectory(this.options.directory, this.options.automaticCategoryNames) : [];\n        commands = commands.concat(await CommandUtil.CommandUtils.parse(require(path.resolve(__dirname, \"commands\"))));\n        await CommandUtil.CommandUtils.prependMiddleware(commands, PermissionGuard);\n\n        for (let command of commands) {\n            if (this.options.preloadExclude && this.options.preloadExclude.includes(command.opts.name)) continue;\n            this.commands[command.opts.name] = command;\n            if (command.opts.aliases) {\n                for (let alias of command.opts.aliases) {\n                    this.commands[alias] = command;\n                }\n            }\n        }\n    }\n\n    /**\n     * Executes the command initiated by the message\n     * @param message the message initiating a command\n     */\n    public async executeCommand(message: Message): Promise<void> {\n        const sendError = async (error: any) => {\n            if (!error) return;\n            if (!message.reject) message.reject = (err = CommandError.GENERIC({})) => {\n                const render = err.render;\n                return message.reply(typeof render === \"string\" ? render : \"\", {embed: typeof render === \"object\" ? render : undefined}) as any as Promise<void>\n            };\n            if (error instanceof CommandError) {\n                return await message.reject(error);\n            }\n            /**\n             * @todo tracking\n             */\n            console.error(error);\n            await message.reject(CommandError.GENERIC({}));\n        };\n        try {\n            await CommandUtil.CommandUtils.executeMiddleware(message, this.globalGuards);\n        } catch (e) {\n            return await sendError(e);\n        }\n        const command = message.command;\n        if (!command || command.opts.enabled === false) {\n            await message.reject(new CommandError({\n                message: `That command doesn't exist! Try \\`${COMMAND_PREFIX}help\\` for a list of commands.`,\n                title: \"Unknown command\"\n            }));\n            return;\n        }\n        try {\n            if (command.opts.guards) {\n                await CommandUtil.CommandUtils.executeMiddleware(message, command.opts.guards);\n            }\n            await command.handler(message, sendError);\n        } catch (e) {\n            return await sendError(e);\n        }\n    }\n}\n\nexport * from \"./util\";\nexport { Guards }\nexport * from \"./errors\";\nexport * from \"./api\";"]}