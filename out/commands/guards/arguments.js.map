{"version":3,"file":"arguments.js","sourceRoot":"./src/","sources":["commands/guards/arguments.ts"],"names":[],"mappings":"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","sourcesContent":["import {Message, RichEmbed} from \"discord.js\";\n\nimport Application from \"../..\";\nimport { COMMAND_PREFIX, WARNING_EMOJI, SUCCESS_EMOJI } from \"../../Constants\";\nimport { CommandHandler } from \"../util\";\n\nexport namespace ArgumentSDK {\n    /**\n     * An argument slot.\n     */\n    export interface Argument {\n        name: string;\n        /**\n         * If the type is a function, it takes the place of a validator function and returns the error or null.\n         */\n        type: \"string\" | \"boolean\" | \"number\" | \"user\" | \"member\" | \"guild\" | \"channel\" | \"message\" | Validator;\n        unlimited?: boolean;\n        required?: boolean;\n    }\n    \n    /**\n     * A function that inspects the arguments and returns errors, or null.\n     * \n     * The function takes the entire argument array but should inspect only one\n     * argument, as each validator function is for a specific argument slot.\n     */\n    export type Validator = (args: string[], message: Message) => Promise<string | null>;\n    \n    /**\n     * Checks the type of a given value\n     * @param value the value to check\n     * @param type the typeof to validate\n     * @param error the error to return\n     */\n    export function parse<T>(value: string, type: string, error: T): {error: T | null, value: any} {\n        try {\n            value = JSON.parse(value);\n            if (typeof value !== type) {\n                return {error, value};\n            }\n            return {error: null, value};\n        } catch (e) {\n            return {error, value};\n        }\n    }\n    \n    /**\n     * Functions related to extracting IDs from strings\n     */\n    export namespace Matching {\n        const channelRegex = /(?:<#)(\\d{17,19})(?:>)/g;\n        const userRegex = /(?:<@!?)(1|\\d{17,19})(?:>)/g;\n    \n        /**\n         * Extracts the channel ID\n         * @param str the string to match\n         */\n        export const channel = (str: string) => {\n            channelRegex.lastIndex = 0;\n            const match = channelRegex.exec(str);\n            return match && match[1];\n        }\n    \n        /**\n         * Extracts the UID\n         * @param str the string to match\n         */\n        export const user = (str: string) => {\n            userRegex.lastIndex = 0;\n            const match = userRegex.exec(str);\n            return match && match[1];\n        }\n    }\n}\n\n/**\n * Creates an argument parsing guard\n * @param desc The command description\n * @param args The command arguments\n * @param command The command itself\n */\nexport const Argumented: (command: string, desc: string, args: Array<ArgumentSDK.Argument | undefined>) => CommandHandler = (command, description, args) => {\n    // every idx of validators array corresponds to args array\n    const validators: Array<{name: string, validator: ArgumentSDK.Validator} | null> = [];\n\n    let syntax: string = `${COMMAND_PREFIX}${command}`;\n\n    for (let i = 0; i < args.length; i++) {\n        const arg = args[i];\n        if (!arg) {\n            // there's no argument data for this, including a name. we use param{idx} as the name\n            syntax += ` <param${i}>`;\n            validators[i] = null;\n            continue;\n        }\n        const {name, type, unlimited, required} = arg;\n        // appends this argument slot to the syntax str\n        syntax += ` <${unlimited ? '...' : ''}${name}${required === false ? \"?\" : \"\"}>`;\n        validators[i] = {\n            name,\n            validator: async (args, msg) => {\n                let text = unlimited ? args.slice(i).join(\" \") : args[i];\n                \n                if (!text || text.length === 0) {\n                    if (required !== false) {\n                        return \"This argument is required.\";\n                    }\n                    return null;\n                }\n\n                switch (type) {\n                    case \"string\":\n                        // there's really nothing to validate if it's a string, it's already a string.\n                        return null;\n                    // boolean and number are identical in how they're parsed, so they're the same handling code\n                    case \"boolean\":\n                    case \"number\":\n                        const result = ArgumentSDK.parse(args[i], type, `Must be a ${type}.`);\n                        args[i] = result.value;\n                        return result.error;\n                    case \"user\":\n                    case \"member\":\n                        let userID = ArgumentSDK.Matching.user(text);\n                        args[i] = userID && (type === \"member\" ? msg.guild.members : msg.client.users).get(userID) as any;\n                        return args[i] ? null : `Must be a ${type}`;\n                    case \"guild\":\n                        args[i] = msg.client.guilds.get(text) as any;\n                        return args[i] ? null : `Must be a ${type}`;\n                    case \"channel\":\n                        let channelID = ArgumentSDK.Matching.channel(text);\n                        args[i] = channelID && msg.client.channels.get(channelID) as any;\n                        return args[i] ? null : `Must be a ${type}`;\n                    case \"message\":\n                        return (args[i] = await msg.channel.fetchMessage(text) as any) ? null : `Must be a ${type}`;\n                    default:\n                        return await type(args, msg);\n                }\n            }\n        };\n    }\n\n    // sets the command metadata for the help command\n    Application.singleton.commandSystem.metadata[command] = {syntax, description};\n\n    return async (message, next) => {\n        // every idx of the issues array corresponds to idx of args array\n        const issues: Array<string | null> = [];\n        let error: boolean = false;\n        for (let i = 0; i < validators.length; i++) {\n            const validator = validators[i];\n            if (!validator) {\n                issues[i] = null;\n                continue;\n            }\n            error = error ? true : !!(issues[i] = await validator.validator(message.args, message));\n        }\n        // there's no errors, so we call next and continue the command flow\n        if (!error) return next();\n        const embed = new RichEmbed();\n        embed.setTitle(`Syntax errors for ${command}`);\n        embed.addField(\"Syntax\", `\\`${syntax}\\``);\n        for (let i = 0; i < issues.length; i++) {\n            const validator = validators[i];\n            // again, we use a placeholder name if there's no validator. this is unlikely to happen though. just satisfies tsc.\n            const name = validator ? validator.name : `param${i}`;\n            const issue = issues[i];\n            // we include the type so we can hint to the user what exactly must be provided,\n            // just in case the error message is vague.\n            let type = args[i] && ` (type: ${args[i]!.type})`;\n            if (typeof type !== \"string\") type = \"\" as any;\n            embed.addField(name, issue ? `${WARNING_EMOJI} ${issue}${type}` : `${SUCCESS_EMOJI}${type}`, true);\n        }\n        await Promise.all([message.reply(embed), message.warning()]);\n    };\n};"]}