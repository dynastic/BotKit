{"version":3,"file":"commands.js","sourceRoot":"./src/","sources":["commands/commands.ts"],"names":[],"mappings":"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","sourcesContent":["import { Client, Collection, Guild, Message, RichEmbed, TextChannel, User } from 'discord.js';\nimport util from 'util';\nimport { Application } from '..';\nimport Constants from '../Constants';\nimport { CommandError } from './errors';\nimport { AccessLevel, Command, Commands } from './util';\n\n\nexport const HelpCommand: Command = {\n    opts: {\n        name: \"help\",\n        access: AccessLevel.EVERYONE,\n        usage: {\n            description: \"Provides help about all commands in this bot\",\n            args: [\n                {\n                    name: \"command\",\n                    type: \"string\", required: false\n                }\n            ]\n        }\n    },\n    handler: async (message, next) => {\n        const [specificCommand] = message.args;\n\n        // command manpage\n        if (specificCommand) {\n            const command = message.client.botkit.commandSystem.commands[specificCommand as string];\n            if (!command) {\n                return next(new CommandError({ message: \"That command does not exist.\" }));\n            }\n            const { usage } = command.opts;\n            if (!usage) {\n                return next(new CommandError({ message: \"There's no additional help data for this command.\" }));\n            }\n            const { description, syntax } = <any>usage as { [key: string]: string };\n            const embed = new RichEmbed();\n            embed.setTitle(`Information about \\`${command.opts.name}\\``);\n            if (description) embed.addField(\"Description\", description);\n            if (syntax) embed.addField(\"Syntax\", `\\`${syntax}\\``);\n            await message.reply(embed);\n            return;\n        }\n\n        const commands: { [category: string]: string[] } = {};\n        const loadedCommands = message.client.botkit.commandSystem.commands;\n\n        for (let commandName in loadedCommands) {\n            if (!(await (message.member || message.author).hasAccess(commandName))) continue;\n            const command = loadedCommands[commandName];\n            if (!command) continue;\n            const category = command.opts.category || \"General\";\n            (commands[category] || (commands[category] = [])).push(`â€¢ \\`${Constants.COMMAND_PREFIX}${command.opts.name}\\``);\n        }\n\n        const helpEmbed = new RichEmbed();\n\n        for (let category in commands) {\n            const commandList = commands[category].join(\"\\n\");\n\n            helpEmbed.addField(`${category}:`, commandList, true);\n        }\n\n        helpEmbed.setTitle(\"Available Commands\");\n\n        message.reply(\"\", { embed: helpEmbed });\n    }\n};\n\nexport const PingCommand: Command = {\n    opts: {\n        name: \"ping\",\n        category: \"Diagnostics\",\n        access: AccessLevel.EVERYONE,\n        usage: {\n            description: \"Calculates the latency between the bot and server\"\n        }\n    },\n    handler: async (message, next) => {\n        const startTime = Date.now();\n\n        const msg = await message.channel.send(\"Ping...\") as Message;\n\n        await msg.edit(`Ponged in ${msg.createdTimestamp - startTime}ms`);\n    }\n};\n\nexport interface Context {\n    message: Message;\n    app: Application;\n    args: string[];\n    author: User;\n    channel: TextChannel;\n    guild: Guild;\n    client: Client;\n    [key: string]: any;\n}\n\nexport const EvalCommand: Command = {\n    opts: {\n        name: \"eval\",\n        category: \"Diagnostics\",\n        access: AccessLevel.ROOT,\n        node: \"debug.eval\",\n        usage: {\n            description: \"Evaluates the given code\",\n            args: [\n                {\n                    type: \"string\",\n                    name: \"code\",\n                    required: true,\n                    unlimited: true\n                }\n            ]\n        }\n    },\n    handler: async (message, next) => {\n        let context: Context = {\n            message,\n            app: message.client.botkit,\n            args: message.args as any[],\n            author: message.author,\n            channel: message.channel as any,\n            guild: message.guild,\n            client: message.client\n        };\n\n        if (message.client.botkit.options.contextPopulator) {\n            context = message.client.botkit.options.contextPopulator(context);\n        }\n\n        let res;\n        try {\n            res = eval(message.args.join(\" \"));\n        } catch (e) {\n            res = e;\n        }\n\n        const getResult = () => \"Result\\n```js\\n\" + util.inspect(res, false, 0) + \"\\n```\";\n\n        if (res instanceof Promise) {\n            const response = await message.reply(\"Promise Pending...\") as Message;\n            try {\n                res = await res;\n            } catch (e) {\n                res = e;\n            }\n\n            await response.edit(getResult());\n            return;\n        }\n\n        await message.reply(getResult());\n    }\n};"]}